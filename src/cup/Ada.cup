package compiladorada;
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import ast.*;
import table.ErrorMsg;


/* Inicializacion  */
parser code {: 
    private List<ErrorMsg> errors = new ArrayList<ErrorMsg>();

    public void report_error(String message, Object info) {       
        /* Alt error print */
        /*
        System.err.print(message);
        System.err.flush();
        if (info instanceof Symbol)
	    if (((Symbol)info).left != -1)
	        System.err.println(" at line " + ((Symbol)info).left +
                                   " of input");
	    else System.err.println("");
        else System.err.println("");
        */
        /*
        System.out.println(message+" at");
        if ( info instanceof ComplexSymbolFactory.ComplexSymbol )
            System.out.println(info);
        else 
            System.err.println("Error : " + message);
        */
        StringBuilder err = new StringBuilder();
        err.append(message);
        err.append(" Expected: ");
        for (Integer i : expected_token_ids()) { 
            if (err.length() != 0) 
                err.append(", ");
            err.append(symbl_name_from_id(i));
        }
        if (info != null && info instanceof Symbol)
            errors.add(new ErrorMsg(((Symbol)info).left, ((Symbol)info).right, err.toString()));
        else
            errors.add(new ErrorMsg(0, 0, err.toString()));
    }
    
    public List<ErrorMsg> getErrors() { 
        return errors;
    }

    public boolean error() { 
        return errors.size() > 0;
    }
:};

/* Terminales */
terminal PUT;
terminal GET;
terminal COMMA;
terminal SEMICOLON;
terminal COLON;
terminal LPAREN;
terminal RPAREN;

/* subprogramas: funciones y procedimientos */
terminal PROCEDURE;
terminal FUNCTION;
terminal IS; 
terminal RETURN; 
terminal IN; 
terminal OUT;
terminal BEGIN;
terminal END;

/* secuencias de control e iteradores */
terminal IF;
terminal THEN;
terminal ELSE;
terminal ELSIF;
terminal WHILE;
terminal LOOP;
terminal EXIT;
terminal WHEN;
terminal FOR;
terminal DOT_DOT;

/* Operadores */
terminal ASSIGN;    // :=
terminal String OPLOG;     // and or
terminal String OPREL;     // = /= < <= > >=
terminal String OPSUM;     // + -
terminal String OPMULT;    //* /
terminal NOT;       //not

/* literales */
terminal BOOLEAN, INTEGER, FLOAT;
terminal NULL;
terminal FALSE, TRUE;
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Float FLOAT_LITERAL;
terminal Integer INTEGER_LITERAL;

/* No-Terminales */
non terminal Program program;
non terminal SubProgramBody subprogram_body;
non terminal Identifier opt_identifier;
non terminal SubProgramSpecification subprogram_specification;
non terminal ParameterList parameters_defs;
non terminal ParameterList parameter_list;
non terminal ParameterDefinition parameter_definition;
non terminal ParameterNameList parameter_name_list;
non terminal Mode mode;
non terminal Expression opt_def_expression;
non terminal DeclarativePart declarative_part;
non terminal DeclarativeItem declarative_item;
non terminal ObjectDeclarativeItem object_declaration;
non terminal IdentifierList identifier_list;
non terminal Statements sequence_of_statements;
non terminal Statement statement;
non terminal NullStatement null_statement;
non terminal AssignStatement assignment_statement;
non terminal ReturnStatement return_statement;
non terminal ExitStatement exit_statement;
non terminal CallStatement call_statement;
non terminal Parameters parameter_part;
non terminal Parameters parameters;
non terminal Expression put_params;
non terminal IfStatement if_statement;
non terminal ElsifStatements elsif_statements;
non terminal Statements else_statement;
non terminal LoopStatement loop_statement;
non terminal IteratorPart iterator;
non terminal Expression opt_expression;
non terminal Expression expression;
non terminal Expression relation;
non terminal Expression simple_expression;
non terminal Expression term;
non terminal Expression factor;
non terminal Expression primary;
non terminal Expression name;
non terminal Type type;

/* Precedencia */
/* Gramatica */
start with program;

program                     ::= subprogram_body:s
                            {: RESULT = new Program(s, sleft, sright); :}
                            ;

subprogram_body             ::= subprogram_specification:s IS
                                    declarative_part:d
                                BEGIN
                                    sequence_of_statements:sq
                                END opt_identifier:oi SEMICOLON
                            {: RESULT = new SubProgramBody(s, d, sq, oi, sleft, sright); :}
                            ;

opt_identifier              ::= IDENTIFIER:i
                            {: RESULT = new Identifier(i, ileft, iright); :}
                            |
                            {: RESULT = null; :}
                            ;

subprogram_specification    ::= PROCEDURE:p IDENTIFIER:i parameters_defs:pd
                            {: RESULT = new SubProgramSpecification("PROCEDURE", new Identifier(i, ileft, iright), pd, null, pleft, pright); :}
                            |   FUNCTION:p IDENTIFIER:i parameters_defs:pd RETURN type:t
                            {: RESULT = new SubProgramSpecification("FUNCTION", new Identifier(i, ileft, iright), pd, t, pleft, pright); :}
                            ;

parameters_defs             ::= LPAREN parameter_list:p RPAREN
                            {: RESULT = p; :}
                            |
                            {: RESULT = new ParameterList(); :}
                            ;

parameter_list              ::= parameter_definition:pd
                            {: ParameterList list = new ParameterList();
                               list.Parameters.add(pd);
                               RESULT = list; :}
                            |   parameter_definition:pd SEMICOLON parameter_list:l
                            {: l.Parameters.add(pd);
                               RESULT = l; :}
                            ;

parameter_definition        ::= parameter_name_list:l COLON mode:m type:t opt_def_expression:e
                            {: RESULT = new ParameterDefinition(l, m, t, e, lleft, lright); :}
                            ;

parameter_name_list         ::= IDENTIFIER:i
                            {: ParameterNameList list = new ParameterNameList();
                               list.Identifiers.add(new Identifier(i, ileft, iright));
                               RESULT = list; :}
                            |   IDENTIFIER:i COMMA parameter_name_list:l
                            {: l.Identifiers.add(new Identifier(i, ileft, iright));
                               RESULT = l; :}
                            ;

mode                        ::= IN:i
                            {: RESULT = new InMode(ileft, iright); :}
                            |   IN:i OUT
                            {: RESULT = new InOutMode(ileft, iright); :}
                            |   OUT:o
                            {: RESULT = new OutMode(oleft, oright); :}
                            |
                            {: RESULT = null; :}
                            ;

opt_def_expression          ::= ASSIGN expression:e
                            {: RESULT = e; :}
                            |
                            {: RESULT = null; :}
                            ;

declarative_part            ::= declarative_item:i declarative_part:d
                            {: d.Items.add(i);
                               RESULT = d; :}
                            |   
                            {: RESULT = new DeclarativePart(); :}
                            ;

declarative_item            ::= object_declaration:o 
                            {: RESULT = o; :}
                            |   subprogram_body:s
                            {: RESULT = s; :}
                            |   error
                            {: RESULT = null; :}
                            ;

object_declaration          ::= identifier_list:l COLON type:t opt_def_expression:e SEMICOLON
                            {: RESULT = new ObjectDeclarativeItem(l, t, e, lleft, lright); :}
                            ;

identifier_list             ::= IDENTIFIER:i
                            {: IdentifierList list = new IdentifierList();
                               list.Identifiers.add(new Identifier(i, ileft, iright));
                               RESULT = list; :}
                            |   IDENTIFIER:i COMMA identifier_list:l
                            {: l.Identifiers.add(new Identifier(i, ileft, iright));
                               RESULT = l; :}
                            ;

sequence_of_statements      ::= statement:s
                            {: Statements sq = new Statements();
                               sq.Statements.add(s);
                               RESULT = sq; :}
                            |   statement:s sequence_of_statements:sq
                            {: sq.Statements.add(s);
                               RESULT = sq; :}
                            ;

put_params                  ::= expression:e
                            {: RESULT = e; :}
                            |   STRING_LITERAL:s
                            {: RESULT = new StringLiteral(s, sleft, sright); :}
                            ;

statement                   ::= null_statement:s
                            {: RESULT = s; :}
                            |   assignment_statement:s
                            {: RESULT = s; :}
                            |   return_statement:s
                            {: RESULT = s; :}
                            |   exit_statement:s
                            {: RESULT = s; :}
                            |   call_statement:s
                            {: RESULT = s; :}
                            |   if_statement:s
                            {: RESULT = s; :}
                            |   loop_statement:s
                            {: RESULT = s; :}
                            |   PUT:p LPAREN put_params:e RPAREN SEMICOLON
                            {: RESULT = new PutStatement(e, pleft, pright); :}
                            |   GET:g LPAREN IDENTIFIER:i RPAREN SEMICOLON
                            {: RESULT = new GetStatement(new Identifier(i, ileft, iright), gleft, gright); :}
                            |   error SEMICOLON
                            {: RESULT = null; :}
                            ;

null_statement              ::= NULL:n SEMICOLON
                            {: RESULT = new NullStatement(nleft, nright); :}
                            ;

assignment_statement        ::= IDENTIFIER:i ASSIGN expression:e SEMICOLON
                            {: RESULT = new AssignStatement(new Identifier(i, ileft, iright), e, ileft, iright); :}
                            ;

return_statement            ::= RETURN:r opt_expression:e SEMICOLON
                            {: RESULT = new ReturnStatement(e, rleft, rright); :}
                            ;

exit_statement              ::= EXIT:x WHEN expression:e
                            {: RESULT = new ExitStatement(e, xleft, xright); :}
                            ;

call_statement              ::= name:n SEMICOLON
                            {: RESULT = new CallStatement(n, nleft, nright); :}
                            ;

parameter_part              ::= parameters:p
                            {: RESULT = p; :}
                            |
                            {: RESULT = new Parameters(); :}
                            ;

parameters                  ::= expression:e
                            {: Parameters p = new Parameters();
                               p.Parameters.add(e);
                               RESULT = p; :}
                            |   parameters:p COMMA expression:e
                            {: p.Parameters.add(e);
                               RESULT = p; :}
                            ;

if_statement                ::= IF:x expression:e THEN 
                                    sequence_of_statements:sq
                                elsif_statements:elsifs
                                else_statement:els
                                END IF SEMICOLON
                            {: RESULT = new IfStatement(e, sq, elsifs, els, xleft, xright); :}
                            ;

elsif_statements            ::= ELSIF:x expression:e THEN
                                    sequence_of_statements:sq
                                elsif_statements:elsifs
                            {: elsifs.ElsifStatements.add(new ElsifStatement(e, sq, xleft, xright));
                               RESULT = elsifs; :}
                            |
                            {: RESULT = new ElsifStatements(); :}
                            ;

else_statement              ::= ELSE:e
                                    sequence_of_statements:sq
                            {: RESULT = sq; :}
                            |
                            {: RESULT = new Statements(); :}
                            ;

loop_statement              ::= iterator:i LOOP:l
                                    sequence_of_statements:sq
                                END LOOP SEMICOLON
                            {: RESULT = new LoopStatement(i, sq, lleft, lright); :}
                            ;

iterator                    ::= WHILE:w expression:e
                            {: RESULT = new IteratorPart("WHILE", null, e, null, wleft, wright); :}
                            |   FOR:f IDENTIFIER:i IN simple_expression:e1 DOT_DOT simple_expression:e2
                            {: RESULT = new IteratorPart("FOR", new Identifier(i, ileft, iright), e1, e2, fleft, fright); :}
                            |
                            {: RESULT = new IteratorPart("LOOP", null, null, null, 0, 0); :}
                            ;

opt_expression              ::= expression:e
                            {: RESULT = e; :}
                            |
                            {: RESULT = null; :}
                            ;

expression                  ::= relation:r
                            {: RESULT = r; :}
                            |   expression:e1 OPLOG:o relation:e2
                            {: RESULT = new LogicalExpression(o, e1, e2, e1left, e1right); :}
                            |   error:e
                            {: RESULT = new ErrorExpression(eleft, eright); :}
                            ;

relation                    ::= simple_expression:e
                            {: RESULT = e; :}
                            |   simple_expression:e1 OPREL:o simple_expression:e2
                            {: RESULT = new AritmeticExpression(o, e1, e2, e1left, e1right); :}
                            ;

simple_expression           ::= OPSUM:o term:t
                            {: RESULT = new UnaryExpression(o, t, oleft, oright); :}
                            |   term:t
                            {: RESULT = t; :}
                            |   simple_expression:e1 OPSUM:o term:e2
                            {: RESULT = new AritmeticExpression(o, e1, e2, e1left, e1right); :}
                            ;

term                        ::= factor:f
                            {: RESULT = f; :}
                            |   term:e1 OPMULT:o factor:e2
                            {: RESULT = new AritmeticExpression(o, e1, e2, e1left, e1right); :}
                            ;

factor                      ::= primary:p
                            {: RESULT = p; :}
                            |   NOT:n primary:p
                            {: RESULT = new NotExpression(p, nleft, nright); :}
                            ;

primary                     ::= name:n
                            {: RESULT = n; :}
                            |   INTEGER_LITERAL:i
                            {: RESULT = new IntegerLiteral(i.intValue(), ileft, iright); :}
                            |   FLOAT_LITERAL:f
                            {: RESULT = new FloatLiteral(f.floatValue(), fleft, fright); :}
                            |   LPAREN expression:e RPAREN
                            {: RESULT = e; :}
                            |   TRUE:e
                            {: RESULT = new True(eleft, eright); :}
                            |   FALSE:e
                            {: RESULT = new False(eleft, eright); :}
                            ;

name                        ::= IDENTIFIER:i
                            {: RESULT = new IdentifierExpression(new Identifier(i, ileft, iright), ileft, iright); :}
                            |   IDENTIFIER:i LPAREN parameter_part:p RPAREN
                            {: RESULT = new CallExpression(new Identifier(i, ileft, iright), p, ileft, iright); :}
                            ;

type                        ::= BOOLEAN:t
                            {: RESULT = new BooleanType(tleft, tright); :}
                            |   FLOAT:t
                            {: RESULT = new FloatType(tleft, tright); :}
                            |   INTEGER:t
                            {: RESULT = new IntegerType(tleft, tright); :}
                            ;
